import{_ as a,o as e,c as i,a2 as r}from"./chunks/framework.DkMK-_fX.js";const b=JSON.parse('{"title":"前端自检系列 --- 数据结构和算法","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"大前端/前端自检/数据结构和算法.md","filePath":"大前端/前端自检/数据结构和算法.md","lastUpdated":1728700067000}'),l={name:"大前端/前端自检/数据结构和算法.md"},t=r('<h1 id="前端自检系列-数据结构和算法" tabindex="-1">前端自检系列 --- 数据结构和算法 <a class="header-anchor" href="#前端自检系列-数据结构和算法" aria-label="Permalink to &quot;前端自检系列 --- 数据结构和算法&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#_1-javascript编码能力">1 JavaScript编码能力</a><ul><li><a href="#_1-1-多种方式实现数组去重、扁平化、对比优缺点">1.1 多种方式实现数组去重、扁平化、对比优缺点</a></li><li><a href="#_1-2-多种方式实现深拷贝、对比优缺点">1.2 多种方式实现深拷贝、对比优缺点</a></li><li><a href="#_1-3-手写函数柯里化工具函数、并理解其应用场景和优势">1.3 手写函数柯里化工具函数、并理解其应用场景和优势</a></li><li><a href="#_1-4-手写防抖和节流工具函数、并理解其内部原理和应用场景">1.4 手写防抖和节流工具函数、并理解其内部原理和应用场景</a></li><li><a href="#_1-5-实现一个sleep函数">1.5 实现一个sleep函数</a></li><li><a href="#_2-手动实现前端轮子">2 手动实现前端轮子</a></li><li><a href="#_2-1-手动实现call、apply、bind">2.1 手动实现call、apply、bind</a></li><li><a href="#_2-2-手动实现符合promise-a-规范的promise、手动实现async-await">2.2 手动实现符合Promise/A+规范的Promise、手动实现async await</a></li><li><a href="#_2-3-手写一个eventemitter实现事件发布、订阅">2.3 手写一个EventEmitter实现事件发布、订阅</a></li><li><a href="#_2-4-可以说出两种实现双向绑定的方案、可以手动实现">2.4 可以说出两种实现双向绑定的方案、可以手动实现</a></li><li><a href="#_2-5-手写json-stringify、json-parse">2.5 手写JSON.stringify、JSON.parse</a></li><li><a href="#_2-6-手写一个模版引擎-并能解释其中原理">2.6 手写一个模版引擎，并能解释其中原理</a></li><li><a href="#_2-7-手写懒加载、下拉刷新、上拉加载、预加载等效果">2.7 手写懒加载、下拉刷新、上拉加载、预加载等效果</a></li><li><a href="#_3-数据结构">3 数据结构</a></li><li><a href="#_3-1-理解常见数据结构的特点-以及他们在不同场景下使用的优缺点">3.1 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点</a></li><li><a href="#_3-2-理解数组、字符串的存储原理-并熟练应用他们解决问题">3.2 理解数组、字符串的存储原理，并熟练应用他们解决问题</a></li><li><a href="#_3-3-理解二叉树、栈、队列、哈希表的基本结构和特点-并可以应用它解决问题">3.3 理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题</a></li><li><a href="#_3-4-了解图、堆的基本结构和使用场景">3.4 了解图、堆的基本结构和使用场景</a></li></ul></li><li><a href="#_4-算法">4 算法</a><ul><li><a href="#_4-1-可计算一个算法的时间复杂度和空间复杂度-可估计业务逻辑代码的耗时和内存消耗">4.1 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗</a></li><li><a href="#_4-2-至少理解五种排序算法的实现原理、应用场景、优缺点-可快速说出时间、空间复杂度">4.2 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度</a></li><li><a href="#_4-3-了解递归和循环的优缺点、应用场景、并可在开发中熟练应用">4.3 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用</a></li><li><a href="#_4-4-可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题">4.4 可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题</a></li><li><a href="#_4-5-前端处理海量数据的算法方案">4.5 前端处理海量数据的算法方案</a></li></ul></li></ul></nav><h2 id="_1-javascript编码能力" tabindex="-1">1 JavaScript编码能力 <a class="header-anchor" href="#_1-javascript编码能力" aria-label="Permalink to &quot;1 JavaScript编码能力&quot;">​</a></h2><h3 id="_1-1-多种方式实现数组去重、扁平化、对比优缺点" tabindex="-1">1.1 多种方式实现数组去重、扁平化、对比优缺点 <a class="header-anchor" href="#_1-1-多种方式实现数组去重、扁平化、对比优缺点" aria-label="Permalink to &quot;1.1 多种方式实现数组去重、扁平化、对比优缺点&quot;">​</a></h3><h3 id="_1-2-多种方式实现深拷贝、对比优缺点" tabindex="-1">1.2 多种方式实现深拷贝、对比优缺点 <a class="header-anchor" href="#_1-2-多种方式实现深拷贝、对比优缺点" aria-label="Permalink to &quot;1.2 多种方式实现深拷贝、对比优缺点&quot;">​</a></h3><h3 id="_1-3-手写函数柯里化工具函数、并理解其应用场景和优势" tabindex="-1">1.3 手写函数柯里化工具函数、并理解其应用场景和优势 <a class="header-anchor" href="#_1-3-手写函数柯里化工具函数、并理解其应用场景和优势" aria-label="Permalink to &quot;1.3 手写函数柯里化工具函数、并理解其应用场景和优势&quot;">​</a></h3><h3 id="_1-4-手写防抖和节流工具函数、并理解其内部原理和应用场景" tabindex="-1">1.4 手写防抖和节流工具函数、并理解其内部原理和应用场景 <a class="header-anchor" href="#_1-4-手写防抖和节流工具函数、并理解其内部原理和应用场景" aria-label="Permalink to &quot;1.4 手写防抖和节流工具函数、并理解其内部原理和应用场景&quot;">​</a></h3><h3 id="_1-5-实现一个sleep函数" tabindex="-1">1.5 实现一个sleep函数 <a class="header-anchor" href="#_1-5-实现一个sleep函数" aria-label="Permalink to &quot;1.5 实现一个sleep函数&quot;">​</a></h3><h3 id="_2-手动实现前端轮子" tabindex="-1">2 手动实现前端轮子 <a class="header-anchor" href="#_2-手动实现前端轮子" aria-label="Permalink to &quot;2 手动实现前端轮子&quot;">​</a></h3><h3 id="_2-1-手动实现call、apply、bind" tabindex="-1">2.1 手动实现call、apply、bind <a class="header-anchor" href="#_2-1-手动实现call、apply、bind" aria-label="Permalink to &quot;2.1 手动实现call、apply、bind&quot;">​</a></h3><h3 id="_2-2-手动实现符合promise-a-规范的promise、手动实现async-await" tabindex="-1">2.2 手动实现符合Promise/A+规范的Promise、手动实现async await <a class="header-anchor" href="#_2-2-手动实现符合promise-a-规范的promise、手动实现async-await" aria-label="Permalink to &quot;2.2 手动实现符合Promise/A+规范的Promise、手动实现async await&quot;">​</a></h3><h3 id="_2-3-手写一个eventemitter实现事件发布、订阅" tabindex="-1">2.3 手写一个EventEmitter实现事件发布、订阅 <a class="header-anchor" href="#_2-3-手写一个eventemitter实现事件发布、订阅" aria-label="Permalink to &quot;2.3 手写一个EventEmitter实现事件发布、订阅&quot;">​</a></h3><h3 id="_2-4-可以说出两种实现双向绑定的方案、可以手动实现" tabindex="-1">2.4 可以说出两种实现双向绑定的方案、可以手动实现 <a class="header-anchor" href="#_2-4-可以说出两种实现双向绑定的方案、可以手动实现" aria-label="Permalink to &quot;2.4 可以说出两种实现双向绑定的方案、可以手动实现&quot;">​</a></h3><h3 id="_2-5-手写json-stringify、json-parse" tabindex="-1">2.5 手写JSON.stringify、JSON.parse <a class="header-anchor" href="#_2-5-手写json-stringify、json-parse" aria-label="Permalink to &quot;2.5 手写JSON.stringify、JSON.parse&quot;">​</a></h3><h3 id="_2-6-手写一个模版引擎-并能解释其中原理" tabindex="-1">2.6 手写一个模版引擎，并能解释其中原理 <a class="header-anchor" href="#_2-6-手写一个模版引擎-并能解释其中原理" aria-label="Permalink to &quot;2.6 手写一个模版引擎，并能解释其中原理&quot;">​</a></h3><h3 id="_2-7-手写懒加载、下拉刷新、上拉加载、预加载等效果" tabindex="-1">2.7 手写懒加载、下拉刷新、上拉加载、预加载等效果 <a class="header-anchor" href="#_2-7-手写懒加载、下拉刷新、上拉加载、预加载等效果" aria-label="Permalink to &quot;2.7 手写懒加载、下拉刷新、上拉加载、预加载等效果&quot;">​</a></h3><h3 id="_3-数据结构" tabindex="-1">3 数据结构 <a class="header-anchor" href="#_3-数据结构" aria-label="Permalink to &quot;3 数据结构&quot;">​</a></h3><h3 id="_3-1-理解常见数据结构的特点-以及他们在不同场景下使用的优缺点" tabindex="-1">3.1 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点 <a class="header-anchor" href="#_3-1-理解常见数据结构的特点-以及他们在不同场景下使用的优缺点" aria-label="Permalink to &quot;3.1 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点&quot;">​</a></h3><h3 id="_3-2-理解数组、字符串的存储原理-并熟练应用他们解决问题" tabindex="-1">3.2 理解数组、字符串的存储原理，并熟练应用他们解决问题 <a class="header-anchor" href="#_3-2-理解数组、字符串的存储原理-并熟练应用他们解决问题" aria-label="Permalink to &quot;3.2 理解数组、字符串的存储原理，并熟练应用他们解决问题&quot;">​</a></h3><h3 id="_3-3-理解二叉树、栈、队列、哈希表的基本结构和特点-并可以应用它解决问题" tabindex="-1">3.3 理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题 <a class="header-anchor" href="#_3-3-理解二叉树、栈、队列、哈希表的基本结构和特点-并可以应用它解决问题" aria-label="Permalink to &quot;3.3 理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题&quot;">​</a></h3><h3 id="_3-4-了解图、堆的基本结构和使用场景" tabindex="-1">3.4 了解图、堆的基本结构和使用场景 <a class="header-anchor" href="#_3-4-了解图、堆的基本结构和使用场景" aria-label="Permalink to &quot;3.4 了解图、堆的基本结构和使用场景&quot;">​</a></h3><h2 id="_4-算法" tabindex="-1">4 算法 <a class="header-anchor" href="#_4-算法" aria-label="Permalink to &quot;4 算法&quot;">​</a></h2><h3 id="_4-1-可计算一个算法的时间复杂度和空间复杂度-可估计业务逻辑代码的耗时和内存消耗" tabindex="-1">4.1 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗 <a class="header-anchor" href="#_4-1-可计算一个算法的时间复杂度和空间复杂度-可估计业务逻辑代码的耗时和内存消耗" aria-label="Permalink to &quot;4.1 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗&quot;">​</a></h3><h3 id="_4-2-至少理解五种排序算法的实现原理、应用场景、优缺点-可快速说出时间、空间复杂度" tabindex="-1">4.2 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度 <a class="header-anchor" href="#_4-2-至少理解五种排序算法的实现原理、应用场景、优缺点-可快速说出时间、空间复杂度" aria-label="Permalink to &quot;4.2 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度&quot;">​</a></h3><h3 id="_4-3-了解递归和循环的优缺点、应用场景、并可在开发中熟练应用" tabindex="-1">4.3 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用 <a class="header-anchor" href="#_4-3-了解递归和循环的优缺点、应用场景、并可在开发中熟练应用" aria-label="Permalink to &quot;4.3 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用&quot;">​</a></h3><h3 id="_4-4-可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题" tabindex="-1">4.4 可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题 <a class="header-anchor" href="#_4-4-可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题" aria-label="Permalink to &quot;4.4 可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题&quot;">​</a></h3><h3 id="_4-5-前端处理海量数据的算法方案" tabindex="-1">4.5 前端处理海量数据的算法方案 <a class="header-anchor" href="#_4-5-前端处理海量数据的算法方案" aria-label="Permalink to &quot;4.5 前端处理海量数据的算法方案&quot;">​</a></h3>',27),h=[t];function o(n,s,_,d,c,f){return e(),i("div",null,h)}const m=a(l,[["render",o]]);export{b as __pageData,m as default};
